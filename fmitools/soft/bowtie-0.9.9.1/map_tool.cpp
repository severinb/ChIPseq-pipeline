#include <iostream>
#include <fstream>
#include <string>
#include <getopt.h>
#include <seqan/sequence.h>
#include <seqan/file.h>
#include "assert_helpers.h"
#include "tokenize.h"
#include "hit.h"
#include "ebwt.h"

enum {
	FORMAT_DEFAULT = 1,
	FORMAT_BIN,
	FORMAT_CONCISE,
	FORMAT_FASTA,
	FORMAT_FASTQ
};

static bool sorthits    = false;          // sort hits before outputting?
static bool verbose     = false;          // be talkative
static bool showVersion = false;          // show version info and exit
static bool refIdx      = false;          // print reference idxs, not names
static int informat     = FORMAT_BIN;     // format of input alignments
static int outformat    = FORMAT_DEFAULT; // format of output alignments
static string ebwt_name = "";             // basename of Bowtie index to get names from

/**
 * Print a detailed usage message to the provided output stream.
 *
 * Manual text converted to C++ string with something like:
 * cat MANUAL  | head -850 | tail -340 | sed -e 's/\"/\\\"/g' | \
 *   sed -e 's/^/"/' | sed -e 's/$/\\n"/'
 */
static void printLongUsage(ostream& out) {
	out <<
	"\n"
	" Using the 'bowtie-maptool' Alignment Converter\n"
	" ----------------------------------------------\n"
	" \n"
	" 'bowtie-maptool' allows the user to convert between alignment formats\n"
	" generated by Bowtie.  It is most useful for converting from Bowtie's\n"
	" compact binary output format (-b/--binout), which is most appropriate\n"
	" for archiving large sets of alignments, to Bowtie's more verbose tab-\n"
	" delimited human-readable format (Bowtie's default output).  It can\n"
	" also be used to sort a set of alignments with respect to the\n"
	" alignments' position on the reference (-s/--sort).  This is a\n"
	" necessary first step to most analyses, including consensus and SNP\n"
	" calling.  At this time, to sort triggered by the -s/--sort option\n"
	" occurs entirely in memory, so sorting very large sets of reads may\n"
	" exhaust memory.\n"
	" \n"
	" For information about converting Bowtie alignment to Maq's .map\n"
	" format, see the next section on using 'bowtie-maqconvert'.\n"
	" \n"
	"  Command Line\n"
	"  ------------\n"
	" \n"
	" Usage: bowtie-maptool [options]* <align_in> [<align_out>]\n"
	" \n"
	"    <align_in>      Alignment file output by bowtie to be converted, or\n"
	"                    \"-\" to convert alignments from stdin.\n"
	"\n"
	"    [<align_out>]   Converted alignment file to output.  Default: write\n"
	"                    alignments to stdout.  <align_out> must be\n"
	"                    specified when -B/--outbin is used.\n"
	"\n"
	" Options:\n"
	"\n"
	"    -d/--indef      <align_in> is in Bowtie's default tab-delimited,\n"
	"                    human-readable output format.\n"
	"\n"
	"    -b/--inbin      <align_in> is in Bowtie's compact binary\n"
	"                    (-b/--binout) format (default).\n"
	"\n"
	"    -D/--outdef     <align_out> will be in Bowtie's default tab-\n"
	"                    delimited, human-readable output format  (default).\n"
	"\n"
	"    -B/--outbin     <align_out> will be in Bowtie's compact binary\n"
	"                    (-b/--binout) format.\n"
	"\n"
	"    -C/--outconcise <align_out> will be in Bowtie's --concise format.\n"
	"\n"
	"    -Q/--outfastq   <align_out> will consist of aligned reads in FASTQ\n"
	"                    format.\n"
	"\n"
	"    -F/--outfasta   <align_out> will consist of aligned reads in FASTA\n"
	"                    format.\n"
	"\n"
	"    -s/--sort       Sort hits by reference position before outputting.\n"
	"                    Sorts first by referene sequence (sequences that\n"
	"                    appeared earlier in the input have priority), then\n"
	"                    by offset into the sequence (alignments appearing\n"
	"                    closer to the left-hand end of the sequence have\n"
	"                    priority).\n"
	"\n"
	"    -n/--names <ebwt> If reference sequence names are needed, obtain them\n"
	"                      from the Bowtie index with basename <ebwt>.\n"
	"\n"
	"    -v/--verbose    Print verbose output (for debugging).\n"
	"\n"
	"    -h/--help       Print detailed description of tool and its options\n"
	"                    (from MANUAL).\n"
	"\n"
	"    --version       Print version information and quit.\n"
	"\n"
	;
}

/**
 * Print a detailed usage message to the provided output stream.
 */
static void printUsage(ostream& out) {
	out << "Usage: bowtie-maptool [options]* <align_in> [<align_out>]" << endl
	    << "  <align_in>         alignment file output by bowtie, or \"-\" for stdin" << endl
	    << "  <align_out>        write output alignments to this file (default: stdout)" << endl
	    << "Options:" << endl
	    << "  -d/--indef         <align_in> is default bowtie output" << endl
	    << "  -b/--inbin         <align_in> is bowtie -b/--binout output (default)" << endl
	    << "  -D/--outdef        <align_out> is default bowtie output  (default)" << endl
	    << "  -B/--outbin        <align_out> is -b/--binout bowtie output" << endl
	    << "  -C/--outconcise    <align_out> is --concise bowtie output" << endl
	    << "  -Q/--outfastq      <align_out> is aligned reads in FASTQ format" << endl
	    << "  -F/--outfasta      <align_out> is aligned reads in FASTA format" << endl
	    << "  -s/--sort          sort hits by reference position before outputting" << endl
	    << "  -n/--names <ebwt>  if needed, get ref names from index w/ basename <ebwt> " << endl
	    << "  -v/--verbose       verbose output (for debugging)" << endl
	    << "  -h/--help          print detailed description of tool and its options" << endl
	    << "  --version          print version information and quit" << endl
	    ;
}

static const char *short_options = "hvsdbsDBCQFn:";

enum {
	ARG_VERSION = 256,
	ARG_REFIDX
};

static struct option long_options[] = {
	{"indef",      no_argument, 0, 'd'},
	{"inbin",      no_argument, 0, 'b'},
	{"outdef",     no_argument, 0, 'D'},
	{"outbin",     no_argument, 0, 'B'},
	{"outconcise", no_argument, 0, 'C'},
	{"outfastq",   no_argument, 0, 'Q'},
	{"outfasta",   no_argument, 0, 'F'},
	{"sort ",      no_argument, 0, 's'},
	{"verbose",    no_argument, 0, 'v'},
	{"names",      no_argument, 0, 'n'},
	{"help",       no_argument, 0, 'h'},
	{"refidx",     no_argument, 0, ARG_REFIDX},
	{"version",    no_argument, 0, ARG_VERSION},
	{0, 0, 0, 0} // terminator
};

/**
 * Read command-line arguments
 */
static void parseOptions(int argc, char **argv) {
    int option_index = 0;
	int next_option;
	do {
		next_option = getopt_long(argc, argv, short_options, long_options, &option_index);
		switch (next_option) {
	   		case 'h':
	   		case '?':
				printLongUsage(cout);
				exit(0);
				break;
	   		case 'v': verbose = true; break;
	   		case 's': sorthits = true; break;
	   		case ARG_VERSION: showVersion = true; break;
	   		case ARG_REFIDX: refIdx = true; break;
	   		case 'd': informat = FORMAT_DEFAULT; break;
	   		case 'b': informat = FORMAT_BIN; break;
	   		case 'D': outformat = FORMAT_DEFAULT; break;
	   		case 'B': outformat = FORMAT_BIN; break;
	   		case 'C': outformat = FORMAT_CONCISE; break;
	   		case 'Q': outformat = FORMAT_FASTQ; break;
	   		case 'F': outformat = FORMAT_FASTA; break;
	   		case 'n': ebwt_name = optarg; break;
			case -1: /* Done with options. */ break;
			case 0: if (long_options[option_index].flag != 0) break;
			default:
				cerr << "Unknown option: " << (char)next_option << endl;
				printUsage(cerr);
				exit(1);
		}
	} while(next_option != -1);
}

/**
 * Print the read involved in an alignment as a FASTQ record.
 */
static void fastqAppend(ostream& out, Hit& h) {
	if(!h.fw) {
		::reverseComplementInPlace(h.patSeq);
		::reverseInPlace(h.quals);
	}
	out << "@" << h.patName << endl
	    << h.patSeq << endl
	    << "+" << endl
	    << h.quals << endl;
}

/**
 * Print the read involved in an alignment as a FASTA record.
 */
static void fastaAppend(ostream& out, Hit& h) {
	if(!h.fw) ::reverseComplementInPlace(h.patSeq);
	out << ">" << h.patName << endl << h.patSeq << endl;
}

/**
 * Parse command-line options, iterate through input alignments and
 * output appropriate converted alignment.
 */
int main(int argc, char **argv) {
	string infile;
	vector<string> infiles;
	string outfile;
	parseOptions(argc, argv);
	ostream *out = &cout;
	if(showVersion) {
		cout << argv[0] << " version " << BOWTIE_VERSION << endl;
		cout << "Built on " << BUILD_HOST << endl;
		cout << BUILD_TIME << endl;
		cout << "Compiler: " << COMPILER_VERSION << endl;
		cout << "Options: " << COMPILER_OPTIONS << endl;
		cout << "Sizeof {int, long, long long, void*, size_t}: {" << sizeof(int)
		     << ", " << sizeof(long) << ", " << sizeof(long long)
		     << ", " << sizeof(void *)
		     << ", " << sizeof(size_t) << "}" << endl;
		cout << "Source hash: " << EBWT_MAPTOOL_HASH << endl;
		return 0;
	}

	// Get input filename
	if(optind >= argc) {
		cerr << "No input alignments file specified!" << endl;
		printUsage(cerr);
		return 1;
	}
	infile = argv[optind++];
	tokenize(infile, ",", infiles);

	// Get output filename
	if(optind < argc) {
		out = new ofstream(argv[optind]);
	} else if(outformat == FORMAT_BIN) {
		cerr << "If -B/--outbin is specified, <align_out> must also be specified" << endl;
		exit(1);
	}

	// Read in reference names, if requested
	vector<string> refnames;
	if(!ebwt_name.empty()) {
		string adjust = adjustEbwtBase(argv[0], ebwt_name, verbose);
		readEbwtRefnames(adjust, refnames);
		if(verbose) {
			cout << "Successfully read " << refnames.size() << " reference sequence names from index" << endl;
		}
	}

	for(size_t i = 0; i < infiles.size(); i++) {
		istream *inp;
		if(infiles[i] == "-") {
			inp = &cin;
		} else {
			inp = new ifstream(infiles[i].c_str(), ios_base::out | ios_base::binary);
		}
		istream& in = *inp;
		vector<Hit> hits;
		while(in.good() && !in.eof()) {
			if(sorthits) {
				hits.resize(hits.size()+1); // add elt on back using default constructor
				bool good;
				vector<string>* inrefnames = &refnames;
				if(informat == FORMAT_BIN) {
					good = BinaryHitSink::readHit(hits.back(), in, inrefnames, verbose);
				} else {
					good = VerboseHitSink::readHit(hits.back(), in, inrefnames, verbose);
				}
				if(!good) {
					hits.pop_back();
					continue; // bad alignment; skip it
				}
			} else {
				Hit h;
				bool good;
				vector<string>* inrefnames = &refnames;
				vector<string>* outrefnames = NULL;
				if(!refIdx) {
					outrefnames = &refnames;
				}
				if(informat == FORMAT_BIN) {
					good = BinaryHitSink::readHit(h, in, inrefnames, verbose);
				} else {
					good = VerboseHitSink::readHit(h, in, inrefnames, verbose);
				}
				if(!good) continue; // bad alignment; skip it

				if(outformat == FORMAT_BIN) {
					BinaryHitSink::append(*out, h, outrefnames, 0);
				} else if(outformat == FORMAT_DEFAULT) {
					VerboseHitSink::append(*out, h, outrefnames, 0 /* partition */, 0);
				} else if(outformat == FORMAT_FASTQ) {
					fastqAppend(*out, h);
				} else if(outformat == FORMAT_FASTA) {
					fastaAppend(*out, h);
				} else {
					ConciseHitSink::append(*out, h, 0, false /* reportOpps */);
				}
			}
		}
		// If the user requested that hits be sorted, sort them in memory and output them now
		if(sorthits) {
			std::sort(hits.begin(), hits.end());
			vector<string>* outrefnames = NULL;
			if(!refIdx) {
				outrefnames = &refnames;
			}
			for(size_t i = 0; i < hits.size(); i++) {
				Hit& h = hits[i];
				if(outformat == FORMAT_BIN) {
					BinaryHitSink::append(*out, h, outrefnames, 0);
				} else if(outformat == FORMAT_DEFAULT) {
					VerboseHitSink::append(*out, h, outrefnames, 0 /* partition */, 0);
				} else if(outformat == FORMAT_FASTQ) {
					fastqAppend(*out, h);
				} else if(outformat == FORMAT_FASTA) {
					fastaAppend(*out, h);
				} else {
					ConciseHitSink::append(*out, h, 0, false /* reportOpps */);
				}
			}
		} else {
			assert_eq(0, hits.size());
		}
		if(infiles[i] != "-") {
			((ifstream*)inp)->close();
			delete inp;
		}
	}

	// Close and delete output
	if(optind < argc) {
		((ofstream*)out)->close();
		delete out;
	}

	return 0;
}
