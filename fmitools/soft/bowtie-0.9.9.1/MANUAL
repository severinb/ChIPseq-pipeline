Bowtie: an Ultrafast, Lightweight Short Read Aligner

Bowtie Manual
=============

 What is Bowtie?
 ---------------

 Bowtie is an ultrafast, memory-efficient short read aligner geared
 toward quickly aligning large sets of short DNA sequences (reads) to
 large genomes. It aligns 35-base-pair reads to the human genome at a
 rate of 25 million reads per hour on a typical workstation. Bowtie
 indexes the genome with a Burrows-Wheeler index to keep its memory
 footprint small: for the human genome, the index is as small as 1.1 GB
 (using -z), and typically about 2.2 GB (not using -z) or 2.9 GB (for
 paired-end alignment).  Bowtie supports alignment policies equivalent
 to Maq and SOAP but is substantially faster: about 35x faster than Maq
 and over 250x faster than SOAP when aligning 35-bp reads to the human
 genome.  Multiple processor cores can be used simultaneously to
 achieve greater alignment speed.  Bowtie's output format can be
 converted to the format used by Maq, allowing users to rapidly align
 reads with Bowtie then identify variations with Maq. The Bowtie tools
 run on the command line under Windows XP, Mac OS X, and Linux.

 What isn't Bowtie?
 ------------------

 Bowtie is not a general-purpose alignment tool like MUMmer, BLAST or
 Vmatch.  Bowtie works best with short reads (though it supports reads
 up to 1024 bases in length) and is designed to be extremely fast for
 read sets where a) many of the reads have at least one good, valid
 alignment, b) many of the reads are relatively high-quality, and c)
 the number of alignments reported per read is small (close to 1).
 These criteria are generally satisfied in the context of mammalian
 resequencing projects, but less competitive running times may be
 observed in other contexts.

 Bowtie does not yet work in ABI "color space," and does not yet report
 gapped alignments.  These featuers are future work.

 Obtaining Bowtie Binaries
 -------------------------

 Obtain Bowtie binaries for your platform from the Download section of
 the Sourceforge project site.  Binaries are currently available for
 Linux, Windows, and Mac OS X.

 https://sourceforge.net/project/showfiles.php?group_id=236897&package_id=288231

 Obtaining and Building Bowtie Sources
 -------------------------------------

 Building Bowtie requires a GNU-like environment that includes GCC, GNU
 Make and other basics.  It should be possible to build Bowtie on
 a vanilla Linux or Mac installation.  Bowtie can also be built on
 Windows using Cygwin or MinGW (MinGW recommended).  If building with
 MinGW, first install MinGW and MSYS (http://www.mingw.org/), the zlib
 library (http://cygwin.com/packages/mingw-zlib/), and the pthreads
 library (http://sourceware.org/pthreads-win32/).  You may also need
 the GnuWin32 core (http://gnuwin32.sf.net/packages/coreutils.htm) and
 other utilities to drive the build process.

 Bowtie depends on code from Maq (http://maq.sf.net) and from the SeqAn
 library (http://www.seqan.de).  However, all supporting code is
 included in the Bowtie source archive, so there is no need to download
 additional sources.

 Obtain Bowtie sources from the Download section of the Sourceforge
 project site:

 https://sourceforge.net/project/showfiles.php?group_id=236897&package_id=288231

 Extract the sources, change to the directory where they were
 extracted, and build the Bowtie tools by running GNU make (usually
 with the command 'make', but sometimes with 'gmake') with no
 arguments.  If building with MinGW, run GNU make from the MSYS
 environment.

 Due to the -p option, Bowtie needs the pthreads library to compile and
 run. To compile Bowtie without pthreads support (which disables the -p
 option), use 'make BOWTIE_PTHREADS=0'.

 Using the 'bowtie' Aligner
 --------------------------

 The 'bowtie' aligner takes an index and a set of reads as input and
 outputs a list of alignments.  Alignments are selected according to a
 combination of the -v/-n/-e/-l options (plus the -I/-X/--lr/--rl/--ll
 options for paired-end alignment), which define which alignments are
 legal, and the -k/-a/-m/--best/--nostrata options which define which
 and how many legal alignments should be reported.

 By default, Bowtie enforces an alignment policy equivalent to Maq's
 quality-aware policy (http://maq.sf.net) (-n 2 -l 28 -e 70), but it
 can also be made to enforce an end-to-end k-difference policy
 equivalent to SOAP's (http://soap.genomics.org.cn/) (-v 2).

 The process by which bowtie chooses an alignment to report is
 randomized in order to avoid "mapping bias" - the phenomenon whereby
 an aligner systematically fails to report a particular class of good
 alignments, causing spurious "holes" in the comparative assembly.
 Whenever bowtie reports a subset of the valid alignments that exist,
 it makes an effort to sample them randomly.  This randomness flows
 from a simple seeded pseudo-random number generator and is
 "deterministic" in the sense that Bowtie will always produce the same
 results when run with the same initial "seed" value (see documentation
 for --seed option).

 Gapped alignments are not currently supported, but we do plan to
 implement this in the future.  Alignment in ABI "color space" is also
 not currently supported.

 Bowtie is designed to be very fast for read sets where a) many of the
 reads have at least one good, valid alignment, b) many of the reads
 are relatively high-quality, c) the number of alignments reported per
 read is small (close to 1).  These criteria are generally satisfied in
 the context of modern short-read analyses such as RNA-seq, ChIP-seq,
 other types of -seq, and especially mammalian genotyping (e.g. the
 1000 Genomes Project).  You may observe longer running times in other
 research contexts.  If you find Bowtie's performance to be
 disappointingly slow, please try the hints described in the "High
 Performance Tips" section below.  If Bowtie continues to be too slow,
 please contact us and tell us the nature of your research application
 and the parameters you are using to run Bowtie.  We are eager to hear
 your feedback.
 
 A result of Bowtie's indexing strategy is that alignments involving
 one or more ambiguous reference characters ('N', '-', 'R' 'Y', etc.)
 are considered invalid by Bowtie, regardless of the alignment policy.
 This is true only for ambiguous characters in the reference;
 alignments involving ambiguous characters in the read are legal,
 subject to the alignment policy.
 
 Also, alignments that "fall off" the reference sequence are not
 considered legal by Bowtie, though some such alignments will become
 legal once gapped alignment is implemented.

  Maq-like Policy
  ---------------

  When the -n option is specified (and it is by default), Bowtie
  determines which alignments are valid according to the following
  policy, which is equivalent to Maq's default policy:

  1. Alignments may have no more than N mismatches in the first L
     bases on the high-quality end of the read.

  2. The sum of the quality values at all mismatched positions may not
     exceed E (where each position has a quality value on a phred-like
     scale of 0 up to about 40).

  The N, L and E parameters are configured using Bowtie's -n, -l and
  -e options.
 
  If there are many possible alignments that satisfy both criteria,
  Bowtie will make an effort to give preference to alignments with
  where the sum from criterion 2 is smaller.  Bowtie does not guarantee
  that it will report the minimum-sum alignment.
  
  Note that Maq internally rounds base qualities to the nearest 10 and
  truncates qualities greater than 30 to 30.  To maintain compatibility
  with Maq, Bowtie does the same.
 
  Also note that bowtie is not fully sensitive in -n 2 and -n 3
  modes by default.  Rather, in those modes bowtie imposes a
  "backtracking limit" to limit the amount of effort spent trying to
  find valid alignments for low-quality reads that are unlikely have
  any.  Since the limit is arbitrary, it may cause bowtie to miss some
  legal 2- and 3-mismatch alignments.  We have set the limit to what we
  consider a reasonable default (125), but the user may decrease or
  increase the limit using the --maxbts and/or -y options.  Setting the
  --maxbts limit to a very large number (>10000) or specifying -y will
  guarantee full sensitivity.
 
  End-to-end k-difference Policy
  ------------------------------
  
  The policy has one criterion: Alignments may have no more than V
  mismatches.  Quality values are ignored.  The number of mismatches
  permitted is configurable with the -v option.
  
  Paired-end Alignment
  --------------------
  
  As of version 0.9.9, Bowtie contains preliminary support for
  paired-end alignment.  Support is described as "preliminary" because
  paired-end alignment only works under the -v alignment policies.
  Also, there is currently no way to get Bowtie to report a mix of
  paired-end alignments and singleton alignments (for unpaired mates
  and/or single-ended reads) in one run; if a mix of alignments is
  desired, the user must first perform a paired-end run using the
  --unfa or --unfq option to write unaligned pairs to files, then run
  Bowtie again in single-ended mode using those files as input.  Future
  versions of Bowtie will expand paired-end support and, hopefully,
  improve performance as well.
  
  A valid paired-end alignment satisfies the following criteria:
  
  1. Both mates have a valid alignment according to the alignment
     policy specified by the -v/-n/-e/-l options.
  2. The relative orientation and position of the mates satisfy the
     constraints given by the -I/-X/--lr/--rl/--ll options. 
  
  Policies governing which paired-end alignments are reported for a
  given read are specified using the -k, -a and -m options as usual.
  The --nostrata and --best options do not apply in paired-end mode.
  
  A paired-end alignment is reported as a pair of mate alignments, both
  on a separate line, where the alignment for each mate is formatted
  the same as an unpaired (singleton) alignment.  The alignment for the
  mate that occurs closest to the beginning of the reference sequence
  (the "upstream" mate) is always printed before the alignment for the
  downstream mate.  Reads files containing paired-end reads will
  sometimes name the reads according to whether they are the #1 or #2
  mates by appending a "/1" or "/2" suffix to the read name.  If no
  such suffix is present in Bowtie's input, the suffix will be added
  when Bowtie prints read names in alignments.
  
  Finding a valid paired-end alignment where both mates align to
  repetitive regions of the reference can be very time-consuming.  By
  default, Bowtie avoids much of this cost by imposing a limit on the
  number of "tries" it makes to match an alignment for one mate with a
  nearby alignment for the other.  The default limit is 100.  This
  causes Bowtie to miss some valid paired-end alignments where both
  mates lie in repetitive regions, but the user may use the --pairtries
  or -y options to increase Bowtie's sensitivity as desired.  
  
  High Performance Tips
  ---------------------
  
  Tip 1: If your computer has multiple processors/cores, try -p
   
  The -p <int> option causes Bowtie to launch <int> parallel search
  threads.  Each thread runs on a different processor/core and all
  threads find alignments in parallel, increasing alignment throughput
  by approximately a multiple of <int>.
  
  Tip 2: If reporting many alignments per read, try tweaking
         'bowtie-build --offrate'
   
  If you are using the -k, -a or -m options and Bowtie is reporting
  many alignments per read (an average of more than about 10 per read)
  and you have some physical memory to spare, then consider building
  an index with a denser SA sample.
  
  To build an index with a denser SA sample, specify a smaller
  --offrate value when running 'bowtie-build'.  A denser SA sample
  leads to a larger index, but is also particularly effective at
  speeding up alignment when then number of alignments reported per
  read is large.  For example, if the number of alignments per read is
  very large, decreasing the index's --offrate by 1 could as much as
  double alignment performance, and decreasing by 2 could quadruple
  alignment performance, etc.
  
  On the other hand, decreasing --offrate increases the size of the
  Bowtie index, both on disk and in memory when aligning reads.  At the
  default --offrate of 5, the SA sample for the human genome occupies
  about 375 MB of memory when aligning reads.  Decreasing the --offrate
  by 1 doubles the memory taken by the SA sample, and decreasing by 2
  quadruples the memory taken, etc.
  
  Tip 3: If bowtie "thrashes", try tweaking 'bowtie --offrate'
  
  If 'bowtie' is very slow and consistently triggers more than a few
  page faults per second (as observed via top or vmstat on Mac/Linux,
  or via a tool like Process Explorer on Windows), then try giving
  bowtie the --offrate <int> option with a larger <int> value than the
  value used when building the index.  For example, bowtie-build's
  default --offrate is 5 and all pre-built indexes available from the
  Bowtie website are built with --offrate 5; so if bowtie thrashes when
  querying such an index, try using 'bowtie --offrate 6'.  If bowtie
  still thrashes, try 'bowtie --offrate 7', etc.  A higher --offrate
  causes bowtie to use a sparser sample of the suffix-array than is
  stored in the index; this saves memory but makes alignment reporting
  slower (which is especially slow when using -a or large -k).
  
  A note from firsthand experience: I have a MacBook Pro with 2 GB of
  RAM and I noticed that 'bowtie -z' would thrash and run very slowly
  when aligning reads against the pre-built human genome available from
  the Bowtie website.  Using 'bowtie -z --offrate 6' prevented the
  thrashing and allowed bowtie to run much faster.

  Command Line
  ------------

  The following is a detailed description of the options used to control
  the 'bowtie' aligner:

 Usage: bowtie [options]* <ebwt> {-1 <mates1> -2 <mates2> | <singles>} [<hits>]

  <ebwt>             The basename of the index to be searched.  The
                     basename is the name of any of the index files up
                     to but not including the final .1.ebwt /
                     .rev.1.ebwt / etc.  bowtie looks for the specified
                     index first in the current directory, then in the
                     'indexes' subdirectory under the directory where
                     the currently-running 'bowtie' executable is
                     located, then looks in the directory specified in
                     the BOWTIE_INDEXES environment variable.

  <mates1>           Comma-separated list of files containing the #1
                     mates (filename usually includes "_1"), or, if -c
                     is specified, the mate sequences themselves.
                     E.g., this might be "flyA_1.fq,flyB_1.fq", or, if
                     -c is given, this might be "GGTCATCCT,ACGGGTCGT".
                     Sequences specified with this option must
                     correspond file-for-file and read-for-read with
                     those specified in <mates2>.  Reads may be a mix
                     of different lengths.  Note that as of version
                     0.9.9.1, bowtie can perform paired-end alignment
                     only under the -v alignment policies; paired-end
                     alignment under the -n alignment policies is
                     future work.

  <mates2>           Comma-separated list of files containing the #2
                     mates (filename usually includes "_2"), or, if -c
                     is specified, the mate sequences themselves.
                     E.g., this might be "flyA_2.fq,flyB_2.fq", or, if
                     -c is given, this might be "GTATGCTG,AATTCAGGCTG".
                     Sequences specified with this option must
                     correspond file-for-file and read-for-read with
                     those specified in <mates1>.  Reads may be a mix
                     of different lengths.  Note that as of version
                     0.9.9.1, bowtie can perform paired-end alignment
                     only under the -v alignment policies; paired-end
                     alignment under the -n alignment policies is
                     future work.

  <singles>          A comma-separated list of files containing the
                     reads to be aligned, or, if -c is specified, the
                     sequences themselves. E.g., this might be
                     "lane1.fq,lane2.fq,lane3.fq,lane4.fq", or, if -c
                     is specified, this might be "GGTCATCCT,ACGGGTCGT".
                     Reads may be a mix of different lengths.

  <hits>             File to write alignments to.  By default,
                     alignments are written to stdout (the console),
                     but a <hits> file must be specified if the
                     -b/--binout option is also specified.

 Options:
 ========

   Input:
   ------

  -q                 The query input files (specified as <mates1>,
                     <mates2> and <singles>) are FASTQ files (usually
                     having extension .fq or .fastq).  This is the
                     default.  See also: --solexa-quals and
                     --integer-quals.

  -f                 The query input files (specified as <mates1>,
                     <mates2> and <singles>) are FASTA files (usually
                     having extension .fa, .mfa, .fna or similar).  All
                     quality values are assumed to be 40 on the Phred
                     scale.

  -r                 The query input files (specified as <mates1>,
                     <mates2> and <singles>) are Raw files: one
                     sequence per line, without quality values or
                     names.  All quality values are assumed to be 40 on
                     the Phred scale.

  -c                 The query sequences are given on command line.
                     I.e. <mates1>, <mates2> and <singles> are comma-
                     separated lists of reads rather than lists of
                     read files.

  -s/--skip <int>    Skip (i.e. do not align) the first <int> reads or
                     pairs in the input.

  -u/--qupto <int>   Only align the first <int> reads or read pairs
                     from the input (after the -s/--skip reads or pairs
                     have been skipped).  Default: no limit.

  -5/--trim5 <int>   Trim <int> bases from high-quality (left) end of
                     each read before alignment (default: 0).

  -3/--trim3 <int>   Trim <int> bases from low-quality (right) end of
                     each read before alignment (default: 0).

  --solexa-quals     Convert FASTQ qualities from solexa-scaled (which
                     can be negative) to phred-scaled (which can't).
                     The formula for conversion is phred-qual =
                     10 * log(1 + 10 ** (solexa-qual/10.0)) / log(10).
                     Used with -q.  Default: off.

  --integer-quals    Quality values are represented in the FASTQ file
                     as space-separated ASCII integers, e.g.,
                     "40 40 30 40...", rather than ASCII characters,
                     e.g., "II?I...".  Used with -q.  Default: off.

   Alignment:
   ----------

  -n/--seedmms <int> The maximum number of mismatches permitted in the
                     "seed", which is the first 28 base pairs of the
                     read by default (see -l/--seedlen).  This may be
                     0, 1, 2 or 3 and the default is 2.
 
  -e/--maqerr <int>  The maximum permitted total of quality values at
                     mismatched read positions.  This total is also
                     called the "quality-weighted hamming distance" or
                     "Q-distance."  This is analogous to the -e option
                     for "maq map".  The default is 70.  Note that,
                     like Maq, Bowtie rounds quality values to the
                     nearest 10 and saturates at 30.
  
  -l/--seedlen <int> The "seed length"; i.e., the number of bases on
                     the high-quality end of the read to which the -n
                     ceiling applies.  The default is 28.

  --nomaqround       Maq accepts quality values in the Phred scale, but
                     internally rounds quality values to the nearest 10
                     saturating at 30.  By default, Bowtie imitates
                     this behavior.  Use --nomaqround to prevent this
                     type of rounding in Bowtie.

  -v <int>           Forego the Maq-like alignment policy and use a
                     SOAP-like alignment policy.  I.e., report end-to-
                     end alignments with at most <int> mismatches.  If
                     -v is specified, base quality values and the -e,
                     -l and -n options are ignored.

  -I/--minins <int>  The minimum insert size for valid paired-end
                     alignments.  E.g. if -I 60 is specified and a
                     paired-end alignment consists of two 20-bp
                     alignments in the appropriate orientation with a
                     20-bp gap between them, that alignment is
                     considered valid (as long as -X is also
                     satisfied).  A 19-bp gap would not be valid in
                     that case.  Default: 0.

  -X/--maxins <int>  The maximum insert size for valid paired-end
                     alignments.  E.g. if -X 100 is specified and a
                     paired-end alignment consists of two 20-bp
                     alignments in the proper orientation with a 60-bp
                     gap between them, that alignment is considered
                     valid (as long as -I is also satisfied).  A 61-bp
                     gap would not be valid in that case.  Default:
                     250.

  --fr/--rf/--ff     The upstream/downstream mate orientations for a
                     valid paired-end alignment against the forward
                     reference strand.  E.g., if --fr is specified and
                     there is a candidate paired-end alignment where
                     mate1 appears upstream of the reverse complement
                     of mate2 and the insert length constraints are
                     met, that alignment is valid.  Also, if mate2
                     appears upstream of the reverse complement of
                     mate1 and all other constraints are met, that too
                     is valid.  --rf likewise requires that an upstream
                     mate1 be reverse-complemented and a downstream
                     mate2 be forward-oriented.  --ll requires both an
                     upstream mate1 and a downstream mate2 to be
                     forward-oriented.  Default: --fr (appropriate for
                     the Illumina short insert library). 

  --maxbts           The maximum number of backtracks permitted when
                     aligning a read in -n 2 or -n 3 mode (default:
                     125).  A "backtrack" is the introduction of a
                     speculative substitution into the alignment.
                     Without this limit, the default parameters will
                     sometimes require that 'bowtie' try 100s or 1,000s
                     of backtracks to align a read, especially if the
                     read has many low-quality bases and/or has no
                     valid alignments, slowing bowtie down
                     significantly.  The drawback of having a limit is
                     that some valid alignments may be missed.  Higher
                     limits yield greater sensitivity at the expensive
                     of longer running times.  See also: -y/--tryhard.

  --pairtries <int>  For paired-end alignment, this is the maximum
                     number of attempts Bowtie will make to match an
                     alignment for one mate up with an alignment for
                     the opposite mate.  Most paired-end alignments
                     require only a few such attempts, but pairs where
                     both mates occur in highly repetitive regions of
                     the reference can require significantly more.
                     Setting this to a higher number allows Bowtie to
                     find more paired-end alignments for repetitive
                     pairs at the expense of speed.  The default is
                     100.  See also: -y/--tryhard.

  -y/--tryhard       Try as hard as possible to find valid alignments
                     when they exist, including paired-end alignments.
                     This is equivalent to specifying very high values
                     for the --maxbts and --pairtries options.  This
                     mode is generally MUCH SLOWER than the default
                     settings, but can be useful for certain research
                     problems.  This mode is slower when (a) the
                     reference is very repetitive, (b) the reads are
                     low quality, or (c) not many reads have valid
                     alignments.

   Reporting:
   ----------

  -k <int>           Report up to <int> valid alignments per read or
                     pair (default: 1).  Validity of alignments is
                     determined by the alignment policy (combined
                     effects of -n, -v, -l, and -e).  If many
                     alignments are reported, they may be subject to
                     stratification; see --best, --nostrata.  Bowtie is
                     designed to be very fast for small -k but BOWTIE
                     CAN BECOME VERY SLOW AS -k INCREASES.  If you
                     would like to use Bowtie for larger values of -k,
                     consider building an index with a denser suffix-
                     array sample, i.e. specify a smaller '--offrate'
                     when invoking 'bowtie-build' for the relevant
                     index.  This will increase the memory footprint of
                     the index, but makes alignment much faster for
                     large -k.

  -a/--all           Report all valid alignments per read or pair
                     (default: off).  Validity of alignments is
                     determined by the alignment policy (combined
                     effects of -n, -v, -l, and -e).  Reported
                     alignments may be subject to stratification; see
                     --best, --nostrata.  Bowtie is designed to be very
                     fast for small -k; BOWTIE CAN BECOME VERY SLOW
                     IF -a/--all IS SPECIFIED.  If you would like to
                     use Bowtie with -a, consider building an index
                     with a denser suffix-array sample, i.e. specify a
                     smaller '--offrate' when invoking 'bowtie-build'
                     for the relevant index.  This will increase the
                     memory footprint of the index, but makes alignment
                     much faster in -a mode.

  -m <int>           Suppress all alignments for a particular read or
                     pair if more than <int> reportable alignments
                     exist for it.  Reportable alignments are those
                     that would be reported given the -n, -v, -l, -e,
                     -k, -a, --best, and --nostrata options.  Default:
                     no limit.  Bowtie is designed to be very fast for
                     small -m but BOWTIE CAN BECOME VERY SLOW AS -m
                     INCREASES.

  --best             Reported singleton alignments must belong to the
                     best possible alignment "stratum" (default: off).
                     A stratum is a category defined by the number of
                     mismatches present in the alignment (for -n, the
                     number of mismatches present in the seed region of
                     the alignment).  E.g., if --best is not specified,
                     Bowtie may sometimes report an alignment with 2
                     mismatches in the seed even though there exists an
                     unreported alignment with 1 mismatch in the seed.
                     BOWTIE IS ABOUT 3-5 TIMES SLOWER WHEN --best IS
                     SPECIFIED.

  --nostrata         If many valid singleton alignments exist and are
                     reportable (according to the --best and -k
                     options) and they fall into more than one
                     alignment "stratum", report all of them.  By
                     default, Bowtie only reports those alignments that
                     fall into the best stratum for which alignments
                     were found, i.e., the one with fewest mismatches.
                     BOWTIE CAN BECOME VERY SLOW WHEN --nostrata IS
                     COMBINED WITH -k OR -a.

   Output:
   -------

  --concise          Print alignments in a concise format. Each line
                     has format 'read_idx{-|+}:<ref_idx,ref_off,mms>',
                     where read_idx is the index of the read mapped,
                     {-|+} is the orientation of the read, ref_idx is
                     the index of the reference sequence aligned to,
                     ref_off is the offset into the reference sequence,
                     and mms is the number of mismatches in the
                     alignment.  Each alignment appears on a separate
                     line.

  -b/--binout        Output alignments in a concise binary format.  If
                     this is specified, <hit_outfile> must also be
                     specified.

  -t/--time          Print the amount of wall-clock time taken by each
                     search phase and index turnover.

  -B/--offbase <int> When outputting alignments, number the first base
                     of a reference sequence as <int>.  Default: 0.
                     (Default is likely to change to 1 in Bowtie 1.0.)

  --quiet            Print nothing besides alignments.

  --refout           Write alignments to a set of files named
                     refXXXXX.map, where XXXXX is the 0-padded index of
                     the reference sequence aligned to.  This can be a
                     useful way to break up work for downstream
                     analyses when dealing with, for example, large
                     numbers of reads aligned to the assembled human
                     genome.  If <hits> is also specified, it will be
                     ignored.

  --refidx           When a reference sequence is referred to in a
                     reported alignment, refer to it by 0-based index
                     (its offset into the list of references that were
                     indexed) rather than by name.

  --unfa <filename>  Write all reads that fail to align to a FASTA file
                     with name <filename>.  Paired-end reads will be
                     written to two parallel files with "_1" and "_2"
                     inserted in the filename, e.g., if <filename> is
                     unaligned.fa, the #1 and #2 mates that fail to
                     align will be written to unaligned_1.fa and
                     unaligned_2.fa respectively.  Unless --maxfa is
                     also specified, reads with a number of valid
                     alignments exceeding the limit set with the -m
                     option are also written to <filename>.

  --unfq <filename>  Write all reads that fail to align to a FASTQ file
                     with name <filename>.  Paired-end reads will be
                     written to two parallel files with "_1" and "_2"
                     inserted in the filename, e.g., if <filename> is
                     unaligned.fq, the #1 and #2 mates that fail to
                     align will be written to unaligned_1.fq and
                     unaligned_2.fq respectively.  Unless --maxfq is
                     also specified, reads with a number of valid
                     alignments exceeding the limit set with the -m
                     option are also written to <filename>.

  --maxfa <filename> Write all reads with a number of valid alignments
                     exceeding the limit set with the -m option to a
                     FASTA file with given name.  Paired-end reads that
                     exceed the -m limit are written to parallel files
                     with "_1" and "_2" inserted into the filename, in
                     the same way as with --unfa.  These reads are not
                     written to the file specified with --unfa.

  --maxfq <filename> Write all reads with a number of valid alignments
                     exceeding the limit set with the -m option to a
                     FASTQ file with given name.  Paired-end reads that
                     exceed the -m limit are written to parallel files
                     with "_1" and "_2" inserted into the filename, in
                     the same way as with --unfq.  These reads are not
                     written to the file specified with --unfq.

   Performance:
   ------------

  -p/--threads <int> Launch <int> parallel search threads (default: 1).
                     Threads will run on separate processors/cores and
                     synchronize when grabbing reads and outputting
                     alignments.  Searching for alignments is almost
                     totally parallel, and speedup is close to linear.
                     Speedup suffers somewhat in -z mode.  This option
                     is only available if bowtie is linked with the
                     pthreads library (i.e. if BOWTIE_PTHREADS=0 is not
                     specified at build time).

  -z/--phased        Alternate between using the forward and mirror
                     indexes in a series of phases such that only one
                     "half" of the index is resident in memory at one
                     time.  This uses about half the amount of memory
                     as the default (which keeps both forward and
                     mirror indexes resident in memory at once), but is
                     somewhat slower, scales worse (see -p), and is
                     incompatible with use of --best or -k greater than
                     1.

  -o/--offrate <int> Override the offrate of the index with <int>.  If
                     <int> is greater than the offrate used to build
                     the index, then some row markings are discarded
                     when the index is read into memory.  This reduces
                     the memory footprint of the aligner but requires
                     more time to calculate text offsets.  <int> must
                     be greater than the value used to build the index.

   Other:
   ------

  --seed <int>       Use <int> as the seed for pseudo-random number
                     generator.

  --verbose          Print verbose output (for debugging).

  --version          Print version information and quit.

  -h/--help          Print detailed description of tool and its options
                     (from MANUAL).

  Default output
  --------------

  The 'bowtie' aligner outputs each alignment on a separate line.  Each
  line is a collection of 8 fields separated by tabs; from left to
  right, the fields are:

   1. Name of read that aligned

   2. Orientation of read in the alignment, '-' for reverse complement,
      '+' otherwise

   3. Name of reference sequence where alignment occurs, or ordinal ID
      if no name was provided

   4. 0-based offset into the reference sequence where leftmost
      character of the alignment occurs

   5. Read sequence (reverse-complemented if orientation is '-')

   6. Read qualities (reversed if orientation is '-')

   7. Reserved

   8. Comma-separated list of mismatch descriptors.  If there are no
      mismatches in the alignment, this field is empty.  A single
      descriptor has the format offset:reference-base>read-base.  The
      offset is expressed as a 0-based offset from the high-quality
      (5') end of the read. 

 Using the 'bowtie-build' Indexer
 --------------------------------

 Use 'bowtie-build' to build a Bowtie index from a set of DNA
 sequences.  bowtie-build outputs a set of 6 files with suffixes
 .1.ebwt, .2.ebwt, .3.ebwt, .4.ebwt, .rev.1.ebwt, and .rev.2.ebwt,
 where the prefix is the <ebwt_outfile_base> parameter supplied by the
 user on the command line.  These files together constitute the index:
 they are all that is needed to align reads to the reference sequences.
 The original sequence files are no longer used by Bowtie once the
 index is built.  

 Use of Karkkainen's blockwise algorithm (see reference #4 below)
 allows bowtie-build to trade off between running time and memory
 usage. bowtie-build has three options governing how it makes this
 trade: -p/--packed, --bmax/--bmaxdivn, and --dcv.  By default, bowtie-
 build will automatically search for the settings that yield the best
 running time without exhausting memory.  This behavior can be disabled
 using the -a/--noauto option.

 The indexer provides options pertaining to the "shape" of the index,
 e.g. --offrate governs the fraction of Burrows-Wheeler rows that are
 "marked" (i.e., the "density" of the suffix-array sample; see
 reference #2).  All of these options are potentially profitable trade-
 offs depending on the application.  They have been set to defaults
 that are reasonable for most cases according to our experiments.  See
 "High Performance Tips" in the "Using the 'bowtie' Aligner" section
 for additional details.

 Because bowtie-build uses 32-bit pointers internally, it can handle up
 to a maximum of 2^32-1 (somewhat more than 4 billion) characters in an
 index.  If your reference exceeds 2^32-1 characters, bowtie-build will
 print an error message and abort.  To resolve this, divide your
 reference sequences into smaller batches and/or chunks and build a
 separate index for each.
 
 If your computer has more than 3-4 GB of memory and you would like to
 exploit that fact to make index building faster, you must use a 64-bit
 version of the bowtie-build binary.  The 32-bit version of the binary
 is restricted to using less than 4 GB of memory.  If a 64-bit pre-
 built binary does not yet exist for your platform on the sourceforge
 download site, you will need to build one from source.

 The Bowtie index is based on the FM Index of Ferragina and Manzini,
 which in turn is based on the Burrows-Wheeler transform.  The
 algorithm used to build the index is based on the blockwise algorithm
 of Karkkainen.  For more information on these techniques, see these
 references:

 1. Burrows M, Wheeler DJ: A block sorting lossless data compression
    algorithm. Digital Equipment Corporation, Palo Alto, CA 1994,
    Technical Report 124.
 2. Ferragina, P. and Manzini, G. 2000. Opportunistic data structures
    with applications. In Proceedings of the 41st Annual Symposium on
    Foundations of Computer Science (November 12 - 14, 2000). FOCS
 3. Ferragina, P. and Manzini, G. 2001. An experimental study of an
    opportunistic index. In Proceedings of the Twelfth Annual ACM-SIAM
    Symposium on Discrete Algorithms (Washington, D.C., United States,
    January 07 - 09, 2001). 269-278.
 4. Karkkainen, J. 2007. Fast BWT in small space by blockwise suffix
    sorting. Theor. Comput. Sci. 387, 3 (Nov. 2007), 249-257

  Command Line
  ------------

 Usage: bowtie-build [options]* <reference_in> <ebwt_outfile_base>

    <reference_in>          A comma-separated list of FASTA files
                            containing the reference sequences to be
                            aligned to, or, if -c is specified, the
                            sequences themselves. E.g., this might be
                            "chr1.fa,chr2.fa,chrX.fa,chrY.fa", or, if
                            -c is specified, this might be
                            "GGTCATCCT,ACGGGTCGT,CCGTTCTATGCGGCTTA".

    <ebwt_outfile_base>     The basename of the index files to write.
                            By default, bowtie-build writes files named
                            NAME.1.ebwt, NAME.2.ebwt, NAME.3.ebwt,
                            NAME.4.ebwt, NAME.rev.1.ebwt, and
                            NAME.rev.2.ebwt, where NAME is the
                            basename.

 Options:

    -f                      The reference input files (specified as
                            <reference_in>) are FASTA files (usually
                            having extension .fa, .mfa, .fna or
                            similar).

    -c                      The reference sequences are given on the
                            command line.  I.e. <reference_in> is a
                            comma-separated list of sequences rather
                            than a list of FASTA files.

    -a/--noauto             Disable the default behavior whereby
                            bowtie-build automatically selects values
                            for --bmax/--dcv/--packed parameters
                            according to the memory available.  User
                            may specify values for those parameters.
                            If memory is exhausted during indexing, an
                            error message will be printed; it is up to
                            the user to try new parameters.

    -p/--packed             Use a packed (2-bits-per-nucleotide)
                            representation for DNA strings.  This saves
                            memory but makes indexing 2-3 times slower.
                            Default: off.  This is configured
                            automatically by default; use -a/--noauto
                            to configure manually.

    --bmax <int>            The maximum number of suffixes allowed in a
                            block.  Allowing more suffixes per block
                            makes indexing faster, but increases memory
                            overhead.  Overrides any previous
                            specification of --bmax, --bmaxmultsqrt or
                            --bmaxdivn.  Default: --bmaxdivn 4.  This
                            is configured automatically by default; use
                            -a/--noauto to configure manually.

    --bmaxdivn <int>        The maximum number of suffixes allowed in a
                            block, expressed as a fraction of the
                            length of the reference.  Overrides any
                            previous specification of --bmax,
                            --bmaxmultsqrt or --bmaxdivn. Default:
                            --bmaxdivn 4.  This is configured
                            automatically by default; use -a/--noauto
                            to configure manually.

    --dcv <int>             Use <int> as the period for the difference-
                            cover sample.  A larger period yields less
                            memory overhead, but may make suffix
                            sorting slower, especially if repeats are
                            present.  Must be a power of 2 no greater
                            than 4096.  Default: 1024.  This is
                            configured automatically by default; use
                            -a/--noauto to configure manually.

    --nodc                  Disable use of the difference-cover sample.
                            Suffix sorting becomes quadratic-time in
                            the worst case (where the worst case is an
                            extremely repetitive reference).  Default:
                            off.

    -r/--noref              Do not build the NAME.3.ebwt and
                            NAME.4.ebwt portions of the index, which
                            contain a bitpacked version of the
                            reference sequences and are (currently)
                            only used for paired-end alignment.

    -3/--justref            Build *only* the NAME.3.ebwt and
                            NAME.4.ebwt portions of the index, which
                            contain a bitpacked version of the
                            reference sequences and are (currently)
                            only used for paired-end alignment.

    -o/--offrate <int>      To map alignments back to positions on the
                            reference sequences, it's necessary to
                            annotate ("mark") some or all of the
                            Burrows-Wheeler rows with their
                            corresponding location on the genome.  The
                            offrate governs how many rows get marked:
                            the indexer will mark every 2^<int> rows.
                            Marking more rows makes reference-position
                            lookups faster, but requires more memory to
                            hold the annotations at runtime.  The
                            default is 5 (every 32nd row is marked; for 
                            human genome, annotations occupy about 340
                            megabytes).  

    -t/--ftabchars <int>    The ftab is the lookup table used to
                            calculate an initial Burrows-Wheeler range
                            with respect to the first <int> characters
                            of the query.  A larger <int> yields a
                            larger lookup table but faster query times.
                            The ftab has size 4^(<int>+1) bytes.  The
                            default is 10 (ftab is 4MB).

    --ntoa                  Convert Ns in the reference sequence to As
                            before building the index.  By default, Ns
                            are simply excluded from the index and
                            'bowtie' will not find alignments that
                            overlap them.

    --big --little          Endianness to use when serializing integers
                            to the index file.  Default: little-endian
                            (recommended for Intel- and AMD-based
                            architectures).

    --seed <int>            Use <int> as the seed for pseudo-random
                            number generator.

    --cutoff <int>          Index only the first <int> bases of the
                            reference sequences (cumulative across
                            sequences) and ignore the rest.

    --oldpmap               bowtie-build switched schemes for mapping
                            "joined" reference locations to original
                            reference locations in version 0.9.8.  The
                            new scheme has the advantage that it does
                            not use padding.  This option activates the
                            old padding-based scheme used in versions
                            prior to 0.9.8.  Versions of 'bowtie' prior
                            to 0.9.8 can query only indexes that use
                            the old scheme.  Version of 'bowtie'
                            starting with 0.9.8 can query indexes using
                            either scheme.  This option will be
                            deprecated in version 1.0. 

    -q/--quiet              bowtie-build is verbose by default.  With
                            this option ebwt-build will print only
                            error messages.

    -h/--help               Print detailed description of tool and its
                            options (from MANUAL).

    --version               Print version information and quit.

 Using the 'bowtie-maptool' Alignment Converter
 ----------------------------------------------

 'bowtie-maptool' allows the user to convert between alignment formats
 generated by Bowtie.  It is most useful for converting from Bowtie's
 compact binary output format (-b/--binout), which is most appropriate
 for archiving large sets of alignments, to Bowtie's more verbose tab-
 delimited human-readable format (Bowtie's default output).  It can
 also be used to sort a set of alignments with respect to the
 alignments' position on the reference (-s/--sort).  This is a
 necessary first step to most analyses, including consensus and SNP
 calling.  At this time, to sort triggered by the -s/--sort option
 occurs entirely in memory, so sorting very large sets of reads may
 exhaust memory.

 For information about converting Bowtie alignment to Maq's .map
 format, see the next section on using 'bowtie-maqconvert'.

  Command Line
  ------------

 Usage: bowtie-maptool [options]* <align_in> [<align_out>]
 
    <align_in>      Alignment file output by bowtie to be converted, or
                    "-" to convert alignments from stdin.

    [<align_out>]   Converted alignment file to output.  Default: write
                    alignments to stdout.  <align_out> must be
                    specified when -B/--outbin is used.

 Options:

    -d/--indef      <align_in> is in Bowtie's default tab-delimited,
                    human-readable output format.

    -b/--inbin      <align_in> is in Bowtie's compact binary
                    (-b/--binout) format (default).

    -D/--outdef     <align_out> will be in Bowtie's default tab-
                    delimited, human-readable output format  (default).

    -B/--outbin     <align_out> will be in Bowtie's compact binary
                    (-b/--binout) format.

    -C/--outconcise <align_out> will be in Bowtie's --concise format.

    -Q/--outfastq   <align_out> will consist of aligned reads in FASTQ
                    format.

    -F/--outfasta   <align_out> will consist of aligned reads in FASTA
                    format.

    -s/--sort       Sort hits by reference position before outputting.
                    Sorts first by referene sequence (sequences that
                    appeared earlier in the input have priority), then
                    by offset into the sequence (alignments appearing
                    closer to the left-hand end of the sequence have
                    priority).

    -v/--verbose    Print verbose output (for debugging).

    -h/--help       Print detailed description of tool and its options
                    (from MANUAL).

    --version       Print version information and quit.

 Using the 'bowtie-maqconvert' Alignment Converter
 -------------------------------------------------

 'bowtie-maqconvert' allows the user to convert from Bowtie's default
 alignment format to the format used by Maq.  This is a necessary first
 step to using Maq's analyses to study Bowtie's output, including
 consensus ('maq assemble') and SNP calling ('maq cns2snp').  Please
 note that, because Bowtie does not mimic Maq's exact calculation for
 alignment "mapping quality," results obtained by feeding Bowtie
 alignments to the Maq tools will generally be less accurate than those
 obtained using Maq's own aligner with the Maq tools.   
 
 The conversion process includes an in-memory sort of all alignments
 with respect to their position on the reference.  This can be
 problematic for very large sets of alignments; sorting so many
 alignments may exhaust memory, causing bowtie-maqconvert to crash or
 run very slowly.  One solution is to split alignments into batches and
 use 'maq mapmerge' to combine outputs from bowtie-maqconvert.  Another
 solution, depending on your application and reference sequences, may
 be to use bowtie's --refout option at alignment time to pre-partition
 alignments into separate files according to the reference sequence
 aligned against.

 Note that Maq changed its output format as of version 0.7.0 in order
 to accomodate read lengths up to 127 bases.  Be sure to use the -o
 option of bowtie-maqconvert if you plan to use the results with a Maq
 version prior to 0.7.0.

  Command Line
  ------------

 Usage: bowtie-maqconvert [options]* <in.bwtmap> <out.map> <chr.bfa>

    <in.bwtmap>   An alignments file generated by Bowtie.  Need not
                  have any particular extension.

    <out.map>     Name of Maq alignment file to output.  Need not have
                  any particular extension.

    <chr.bfa>     The .bfa version of the reference sequences(s).  Use
                  'maq fasta2bfa' to build this.  It must be built
                  using the exact same reference sequences as were used
                  to build the Bowtie index.

 Options:

    -o            Output uses Maq's old (pre-0.7.0) format.

    -v            Print verbose output (for debugging).

    -h/-?         Print detailed description of tool and its options
                  (from MANUAL).

 Using the 'bowtie-inspect' Index Inspector
 ------------------------------------------

 'bowtie-inspect' extracts information from a Bowtie index about the
 original reference sequences used to build it.  By default, the tool
 will output a FASTA file containing the sequences of the original
 references (with all non-A/C/G/T characters converted to Ns).  It can
 also be used to extract just the reference sequence names using the -n
 option.

  Command Line
  ------------

 Usage: bowtie-inspect [options]* <ebwt_base>

  <ebwt_base>        The basename of the index to be inspected.  The
                     basename is the name of any of the four index
                     files up to but not including the first period.
                     bowtie first looks in the current directory for
                     the index files, then looks in the 'indexes'
                     subdirectory under the directory where the
                     currently-running 'bowtie' executable is located,
                     then looks in the directory specified in the
                     BOWTIE_INDEXES environment variable.

 Options:

  -a/--across <int>  When printing FASTA output, output a newline
                     character every <int> bases (default: 60).

  -n/--names         Print reference sequence names only; ignore
                     sequence.

  -v/--verbose       Print verbose output (for debugging).

  -h/--help          Print detailed description of tool and its options
                     (from MANUAL).
